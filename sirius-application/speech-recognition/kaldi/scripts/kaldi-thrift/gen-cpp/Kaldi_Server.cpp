// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.


#include <stdio.h>
#include <iostream>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string>
#include <fstream>
#include <sstream>
#include <sox.h>

#include "KaldiService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace std;
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

void readFromPipe(int,string&);
void sox();

class KaldiServiceHandler : virtual public KaldiServiceIf {
 public:
  KaldiServiceHandler() {
    // Your initialization goes here
  	
	}
  void kaldi_asr(std::string& _return, const std::string& audio_file) {
		string kotae;
	
	pid_t pid;
	int fds[2];
	int fds2[2];	
	
	pipe (fds);
	pipe (fds2);
	pid=fork();
	
	if(pid ==0){  	
		close (fds[1]);
		close (fds2[0]);
	 	dup2(fds[0],STDIN_FILENO);
		dup2(fds2[1],STDOUT_FILENO);	
	 	execl("../../../src/online2bin/online2-wav-nnet2-latgen-faster",
					"--do-endpointing=false",
					"--online=true",
					"--config=../../nnet_a_gpu_online/conf/online_nnet2_decoding.conf",
					"--max-active=7000",
					"--beam=15.0",
					"--lattice-beam=6.0",
					"--acoustic-scale=0.1",
					"--word-symbol-table=../../graph/words.txt",
					"../../nnet_a_gpu_online/smbr_epoch2.mdl", 
					"../../graph/HCLG.fst",
					"\"ark:echo utterance-id1 utterance-id1|\"",
					"\"scp:echo utterance-id1 null|\"",
					"ark:/dev/null",(char*)NULL);
	
		perror("Launch process fail");	
	}	
	else if(pid <0){
		perror("fork");
	}
	else {
			std::string audio_path = "inputserver.wav";
			ofstream audiofile(audio_path.c_str(), ios::binary);
			audiofile.write(audio_file.c_str(),audio_file.size());
			audiofile.close();
	
			std::cout << "Decoding audio file...." <<std::endl;
			sox();
		
			FILE * stream;
			close (fds[0]);
			close (fds2[1]);
			stream = fdopen (fds[1],"w");
			fprintf (stream, "inputserver1.wav");
			fflush(stream);
			close(fds[1]);
			readFromPipe(fds2[0],kotae);
		}	
		_return = kotae;
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<KaldiServiceHandler> handler(new KaldiServiceHandler());
  shared_ptr<TProcessor> processor(new KaldiServiceProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}
void readFromPipe( int fd, string& kotae )
{
    FILE *stream;
    int ch;
		char buffer[4096];
    if ( (stream = fdopen( fd, "r" )) == NULL )
    {
        perror( "fdopen() r" );
    }
    while ( fgets (buffer, sizeof (buffer), stream) != NULL )
				kotae =buffer;
    fflush( stream );
}

void sox(){

 static sox_format_t * in, * out; /* input and output files */
  sox_effects_chain_t * chain;
  sox_effect_t * e;
  char * args[10];
  sox_signalinfo_t interm_signal; /* @ intermediate points in the chain. */
   
	sox_signalinfo_t out_signal = {
    8000,
    1,
    SOX_DEFAULT_PRECISION,
    SOX_UNKNOWN_LEN,
    NULL
  };

  assert(sox_init() == SOX_SUCCESS);
  assert(in = sox_open_read("inputserver.wav", NULL, NULL, NULL));
  assert(out = sox_open_write("inputserver1.wav", &out_signal, NULL, NULL, NULL, NULL));

  chain = sox_create_effects_chain(&in->encoding, &out->encoding);

  interm_signal = in->signal; /* NB: deep copy */

  e = sox_create_effect(sox_find_effect("input"));
  args[0] = (char *)in, assert(sox_effect_options(e, 1, args) == SOX_SUCCESS);
  assert(sox_add_effect(chain, e, &in->signal, &in->signal) == SOX_SUCCESS);
  free(e);

  if (in->signal.rate != out->signal.rate) {
    e = sox_create_effect(sox_find_effect("rate"));
    assert(sox_effect_options(e, 0, NULL) == SOX_SUCCESS);
    assert(sox_add_effect(chain, e, &interm_signal, &out->signal) == SOX_SUCCESS);
    free(e);
  }
  if (in->signal.channels != out->signal.channels) {
    e = sox_create_effect(sox_find_effect("channels"));
    assert(sox_effect_options(e, 0, NULL) == SOX_SUCCESS);
    assert(sox_add_effect(chain, e, &interm_signal, &out->signal) == SOX_SUCCESS);
    free(e);
  }

  /* Create the `flanger' effect, and initialise it with default parameters: */
  e = sox_create_effect(sox_find_effect("norm"));
  assert(sox_effect_options(e, 0, NULL) == SOX_SUCCESS);
  /* Add the effect to the end of the effects processing chain: */
  assert(sox_add_effect(chain, e, &interm_signal, &out->signal) == SOX_SUCCESS);
  free(e);


	e = sox_create_effect(sox_find_effect("output"));
  args[0] = (char *)out, assert(sox_effect_options(e, 1, args) == SOX_SUCCESS);
  assert(sox_add_effect(chain, e, &interm_signal, &out->signal) == SOX_SUCCESS);
  free(e);

  sox_flow_effects(chain, NULL, NULL);

  sox_delete_effects_chain(chain);
  sox_close(out);
  sox_close(in);
  sox_quit();

}
